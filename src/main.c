/**
 * @file main.c
 * @brief Main file.
 *
 * Copyright (C) 2022 Pedro Aguilar <paguilar@paguilar.org>
 * Released under the terms of the GNU GPL v2.0.
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <errno.h>

#include <glib-2.0/glib.h>
#include <glibconfig.h>

#include "graph_create.h"
#include "graph_exec.h"

gint    debug_level;
gchar   *debug_module;
gchar   *deps_file;
gint    cpu_num;

static GOptionEntry opt_entries[] =
{
    { "filename", 'f', 0, G_OPTION_ARG_FILENAME, &deps_file,
        "Mandatory dependencies file generated by pbuilder.py", NULL },
    { "cpu", 'c', 0, G_OPTION_ARG_INT, &cpu_num,
        "Max number of CPUs used to build. Default: 0 (Auto-detect)", NULL },
    { "debug_level", 'l', 0, G_OPTION_ARG_INT, &debug_level,
        "Set debug level. Values: [1-3]. Default: 0 (disabled)", NULL },
    { "debug_module", 'm', 0, G_OPTION_ARG_STRING, &debug_module,
        "Set module to debug. Values: all, create, execute, none. Default: none", NULL },
    { NULL }
};

static PBResult pb_get_env(PBMain pg)
{
    if (!pg)
        return PB_FAIL;

    pg->env = g_new0(struct pbuilder_env_st, 1);

    pg->env->build_dir = getenv("BUILD_DIR");
    if (!pg->env->build_dir) {
        pb_log(LOG_ERR, "%s(): Failed to get environment variable BUILD_DIR", __func__);
        return PB_FAIL;
    }

    /* Some packages, like zstd, use this environment variable in a different manner,
     * so keeping it set causes problems */
    unsetenv("BUILD_DIR");

    pg->env->config_dir = getenv("CONFIG_DIR");
    if (!pg->env->config_dir) {
        pb_log(LOG_ERR, "%s(): Failed to get environment variable CONFIG_DIR", __func__);
        return PB_FAIL;
    }

    pg->env->br2_external = getenv("BR2_EXTERNAL");
    if (!pg->env->br2_external) {
        pb_log(LOG_ERR, "%s(): Failed to get environment variable BR2_EXTERNAL", __func__);
        return PB_FAIL;
    }

    if (debug_level >= 2) {
        printf("Environment variables:\n");
        printf("\tBUILD_DIR: %s\n", pg->env->build_dir);
        printf("\tCONFIG_DIR: %s\n", pg->env->config_dir);
        printf("\tBR2_EXTERNAL: '%s'\n", pg->env->br2_external);
    }

    return PB_OK;
}

static PBResult pb_create_main_struct(PBMain *pbg)
{
    PBMain pg;

    pg = g_new0(struct pbuilder_main_st, 1);
    pg->graph = NULL;
    pg->timer = NULL;
    pg->env = NULL;
    pg->br2_ext_file = NULL;

    if (cpu_num < 1 || cpu_num > g_get_num_processors())
        pg->cpu_num = g_get_num_processors();
    else
        pg->cpu_num = cpu_num;

    if (pb_get_env(pg) != PB_OK) {
        pb_log(PB_ERR, "Failed to get environment variables");
        pb_graph_free(pg);
        return PB_FAIL;
    }

    *pbg = pg;

    return PB_OK;
}

int main(int argc, char *argv[]) 
{
    GOptionContext  *opt_context;
    GError          *error = NULL;
    PBMain          pbg;	/* Main struct: Parallel Build Graph */

    opt_context = g_option_context_new (PBUILDER_DESC);
    g_option_context_add_main_entries (opt_context, opt_entries, NULL);
    if (!g_option_context_parse (opt_context, &argc, &argv, &error)) {
        pb_log(PB_ERR, "Error while parsing options: %s. Aborting!", error->message);
        return EXIT_FAILURE;
    }

    if (!debug_module) {
        debug_module = g_new0(gchar, 4);
        g_snprintf(debug_module, 4, "all");
    }

    if (!deps_file) {
        pb_log(PB_ERR, "No dependencies filename given. Aborting!");
        g_option_context_free(opt_context);
        return EXIT_FAILURE;
    }

    if (access(deps_file, R_OK) != 0) {
        pb_log(PB_ERR, "Invalid dependencies file: %s", strerror(errno));
        g_option_context_free(opt_context);
        return EXIT_FAILURE;
    }

    if (pb_create_main_struct(&pbg) != PB_OK) {
        pb_log(PB_ERR, "Failed to create main struct");
        g_option_context_free(opt_context);
        return EXIT_FAILURE;
    }

    if (pb_graph_create(pbg) != PB_OK) {
        pb_log(PB_ERR, "Failed to create graph");
        g_option_context_free(opt_context);
        return EXIT_FAILURE;
    }

    if (pb_graph_exec(pbg) != PB_OK) {
        pb_log(PB_ERR, "Failed to execute graph");
        pb_graph_free(pbg);
        g_option_context_free(opt_context);
        return EXIT_FAILURE;
    }

    pb_graph_free(pbg);

    g_option_context_free(opt_context);

    return EXIT_SUCCESS;
}
